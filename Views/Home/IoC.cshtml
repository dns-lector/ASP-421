@{
    ViewData["Title"] = "IoC";
}

<div class="text-center">
    <h1 class="display-4">Інверсія управління (Inversion of Control)</h1>
</div>
<p>
    Інверсія управління - архітектурний патерн, згідно з яким задачі зі 
    створення об'єктів (управління їх життєвим циклом) перекладаються на 
    окремий модуль - інжектор або контейнер сервісів.
</p>
<p>
    Перший етап - реєстрація сервісів. До контейнера додаються відомості про 
    класи сервісів та часову область їх існування.
</p>
<p>
    Другий етап - інжекція сервісів. До класів, що потребують сервіси, додаються
    інструкції з їх інжектування (підключення).
</p>
<p>
    Третій (циклічний) етап - Resolve - створення об'єктів, передача їм усі 
    необхідні сервіси з урахуванням можливості їх перестворення.
</p>
<hr/>
<h3>Створення та реєстрація сервісів</h3>
<ul>
    <li>Користуємось принципом DIP (з SOLID) Dependency Inversion Principle:
        залежності створюються від максимально можливої абстракції, 
        створюємо інтерфейс для сервісу (Services/Random/IRandomService).
    </li>
    <li>Створюємо клас - імплементацію інтерфейсу (Services/Random/DefaultRandomService)</li>
    <li>Реєструємо сервіс у Program.cs</li>
</ul>

<h3>Інжекція сервісів</h3>
<ul>
    <li>За можливості інжекція має здійснюватись через конструктори.
        Приклад - інжекція логера
    </li>
    <li>Викликаємо сервіс, отримаємо результат: @ViewData["otp"]</li>
</ul>
